# UUID External Identifiers

## Overview

Use UUIDs as primary keys (named `uid`) instead of sequential integers to prevent enumeration attacks and reduce information leakage.

## Motivation

Sequential integer IDs expose information and enable attacks:

1. **Enumeration**: Attackers can probe `/api/users/1`, `/api/users/2`, etc. to discover resources
2. **Information disclosure**: IDs reveal resource count, creation order, and growth rate
3. **IDOR risk**: If an authorization bug exists, guessable IDs make exploitation trivial

UUIDs provide defense-in-depth without replacing proper authorization checks.

## Design

Use UUIDs directly as primary keys named `uid`. This is a clean-slate change to the initial schema - no migration needed.

### UUID Versions

- **UUIDv4 (random)**: Used for `users`, `databases`, `access_grants` - generated by PostgreSQL via `gen_random_uuid()`
- **UUIDv7 (time-ordered)**: Used for `connections`, `queries`, `query_result_rows`, `audit_log` - generated in Go code before insert

UUIDv7 benefits for high-volume tables:
- Time-ordered for better B-tree index performance (sequential inserts)
- Natural chronological ordering embedded in the UUID
- Still contains enough randomness to prevent guessing

## Schema Changes

Update the initial schema (`internal/migrations/sql/20260107000000_initial_schema.up.sql`) to use `uid UUID` instead of `id BIGSERIAL`:

### users

```sql
CREATE TABLE users (
    uid UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username TEXT NOT NULL UNIQUE,
    password_hash TEXT NOT NULL,
    is_admin BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE INDEX idx_users_username ON users(username);
```

### databases

```sql
CREATE TABLE databases (
    uid UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    host TEXT NOT NULL,
    port INT NOT NULL DEFAULT 5432,
    database_name TEXT NOT NULL,
    username TEXT NOT NULL,
    password_encrypted BYTEA NOT NULL,
    ssl_mode TEXT NOT NULL DEFAULT 'prefer',
    created_by UUID REFERENCES users(uid),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE INDEX idx_databases_name ON databases(name);
```

### connections (UUIDv7)

```sql
CREATE TABLE connections (
    uid UUID PRIMARY KEY,  -- UUIDv7 generated in Go
    user_id UUID NOT NULL REFERENCES users(uid),
    database_id UUID NOT NULL REFERENCES databases(uid),
    source_ip INET NOT NULL,
    connected_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_activity_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    disconnected_at TIMESTAMPTZ,
    queries INT NOT NULL DEFAULT 0,
    bytes_transferred BIGINT NOT NULL DEFAULT 0
);
CREATE INDEX idx_connections_user_id ON connections(user_id);
CREATE INDEX idx_connections_database_id ON connections(database_id);
CREATE INDEX idx_connections_connected_at ON connections(connected_at);
```

### queries (UUIDv7)

```sql
CREATE TABLE queries (
    uid UUID PRIMARY KEY,  -- UUIDv7 generated in Go
    connection_id UUID NOT NULL REFERENCES connections(uid) ON DELETE CASCADE,
    sql_text TEXT NOT NULL,
    parameters jsonb,
    executed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    duration_ms NUMERIC(10,3),
    rows_affected BIGINT,
    error TEXT
);
CREATE INDEX idx_queries_connection_id ON queries(connection_id);
CREATE INDEX idx_queries_executed_at ON queries(executed_at);
```

### query_result_rows (UUIDv7)

```sql
CREATE TABLE query_result_rows (
    uid UUID PRIMARY KEY,  -- UUIDv7 generated in Go
    query_id UUID NOT NULL REFERENCES queries(uid) ON DELETE CASCADE,
    row_number INT NOT NULL,
    row_data JSONB NOT NULL,
    row_size_bytes BIGINT NOT NULL
);
CREATE INDEX idx_query_result_rows_query_id ON query_result_rows(query_id);
```

### access_grants

```sql
CREATE TABLE access_grants (
    uid UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(uid),
    database_id UUID NOT NULL REFERENCES databases(uid),
    access_level TEXT NOT NULL CHECK (access_level IN ('read', 'write')),
    granted_by UUID NOT NULL REFERENCES users(uid),
    starts_at TIMESTAMPTZ NOT NULL,
    expires_at TIMESTAMPTZ NOT NULL,
    revoked_at TIMESTAMPTZ,
    revoked_by UUID REFERENCES users(uid),
    max_query_counts INT,
    max_bytes_transferred BIGINT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT valid_time_window CHECK (starts_at < expires_at)
);
CREATE INDEX idx_access_grants_user_id ON access_grants(user_id);
CREATE INDEX idx_access_grants_database_id ON access_grants(database_id);
CREATE INDEX idx_access_grants_expires_at ON access_grants(expires_at);
CREATE INDEX idx_access_grants_active ON access_grants(user_id, database_id) WHERE revoked_at IS NULL;
```

### audit_log (UUIDv7)

```sql
CREATE TABLE audit_log (
    uid UUID PRIMARY KEY,  -- UUIDv7 generated in Go
    event_type TEXT NOT NULL,
    user_id UUID REFERENCES users(uid),
    performed_by UUID REFERENCES users(uid),
    details JSONB,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE INDEX idx_audit_log_user_id ON audit_log(user_id);
CREATE INDEX idx_audit_log_performed_by ON audit_log(performed_by);
CREATE INDEX idx_audit_log_event_type ON audit_log(event_type);
CREATE INDEX idx_audit_log_created_at ON audit_log(created_at);
```

## Model Changes

### User

```go
import "github.com/google/uuid"

type User struct {
    bun.BaseModel `bun:"table:users,alias:u"`

    UID          uuid.UUID `bun:"uid,pk,type:uuid,default:gen_random_uuid()" json:"uid"`
    Username     string    `bun:"username,notnull,unique" json:"username"`
    PasswordHash string    `bun:"password_hash,notnull" json:"-"`
    IsAdmin      bool      `bun:"is_admin,notnull,default:false" json:"is_admin"`
    CreatedAt    time.Time `bun:"created_at,notnull,default:current_timestamp" json:"created_at"`
    UpdatedAt    time.Time `bun:"updated_at,notnull,default:current_timestamp" json:"updated_at"`
}
```

### Database

```go
type Database struct {
    bun.BaseModel `bun:"table:databases,alias:d"`

    UID               uuid.UUID  `bun:"uid,pk,type:uuid,default:gen_random_uuid()" json:"uid"`
    Name              string     `bun:"name,notnull,unique" json:"name"`
    Description       string     `bun:"description" json:"description"`
    Host              string     `bun:"host,notnull" json:"host"`
    Port              int        `bun:"port,notnull,default:5432" json:"port"`
    DatabaseName      string     `bun:"database_name,notnull" json:"database_name"`
    Username          string     `bun:"username,notnull" json:"username"`
    Password          string     `bun:"-" json:"-"`
    PasswordEncrypted []byte     `bun:"password_encrypted,notnull" json:"-"`
    SSLMode           string     `bun:"ssl_mode,notnull,default:'prefer'" json:"ssl_mode"`
    CreatedBy         *uuid.UUID `bun:"created_by,type:uuid" json:"created_by"`
    CreatedAt         time.Time  `bun:"created_at,notnull,default:current_timestamp" json:"created_at"`
    UpdatedAt         time.Time  `bun:"updated_at,notnull,default:current_timestamp" json:"updated_at"`
}
```

### Connection (UUIDv7)

```go
type Connection struct {
    bun.BaseModel `bun:"table:connections,alias:c"`

    UID              uuid.UUID  `bun:"uid,pk,type:uuid" json:"uid"`  // UUIDv7 set in Go
    UserID           uuid.UUID  `bun:"user_id,notnull,type:uuid" json:"user_id"`
    DatabaseID       uuid.UUID  `bun:"database_id,notnull,type:uuid" json:"database_id"`
    SourceIP         string     `bun:"source_ip,notnull,type:inet" json:"source_ip"`
    ConnectedAt      time.Time  `bun:"connected_at,notnull,default:current_timestamp" json:"connected_at"`
    LastActivityAt   time.Time  `bun:"last_activity_at,notnull,default:current_timestamp" json:"last_activity_at"`
    DisconnectedAt   *time.Time `bun:"disconnected_at" json:"disconnected_at"`
    Queries          int64      `bun:"queries,notnull,default:0" json:"queries"`
    BytesTransferred int64      `bun:"bytes_transferred,notnull,default:0" json:"bytes_transferred"`
}
```

### Query (UUIDv7)

```go
type Query struct {
    bun.BaseModel `bun:"table:queries,alias:q"`

    UID          uuid.UUID        `bun:"uid,pk,type:uuid" json:"uid"`  // UUIDv7 set in Go
    ConnectionID uuid.UUID        `bun:"connection_id,notnull,type:uuid" json:"connection_id"`
    SQLText      string           `bun:"sql_text,notnull" json:"sql_text"`
    Parameters   *QueryParameters `bun:"parameters,type:jsonb" json:"parameters,omitempty"`
    ExecutedAt   time.Time        `bun:"executed_at,notnull,default:current_timestamp" json:"executed_at"`
    DurationMs   *float64         `bun:"duration_ms,type:numeric(10,3)" json:"duration_ms"`
    RowsAffected *int64           `bun:"rows_affected" json:"rows_affected"`
    Error        *string          `bun:"error" json:"error"`
}
```

### QueryResultRow (UUIDv7)

```go
type QueryResultRow struct {
    bun.BaseModel `bun:"table:query_result_rows,alias:qrr"`

    UID          uuid.UUID       `bun:"uid,pk,type:uuid" json:"uid"`  // UUIDv7 set in Go
    QueryID      uuid.UUID       `bun:"query_id,notnull,type:uuid" json:"query_id"`
    RowNumber    int             `bun:"row_number,notnull" json:"row_number"`
    RowData      json.RawMessage `bun:"row_data,notnull,type:jsonb" json:"row_data"`
    RowSizeBytes int64           `bun:"row_size_bytes,notnull" json:"row_size_bytes"`
}
```

### AccessGrant

```go
type AccessGrant struct {
    bun.BaseModel `bun:"table:access_grants,alias:ag"`

    UID                 uuid.UUID  `bun:"uid,pk,type:uuid,default:gen_random_uuid()" json:"uid"`
    UserID              uuid.UUID  `bun:"user_id,notnull,type:uuid" json:"user_id"`
    DatabaseID          uuid.UUID  `bun:"database_id,notnull,type:uuid" json:"database_id"`
    AccessLevel         string     `bun:"access_level,notnull" json:"access_level"`
    GrantedBy           uuid.UUID  `bun:"granted_by,notnull,type:uuid" json:"granted_by"`
    StartsAt            time.Time  `bun:"starts_at,notnull" json:"starts_at"`
    ExpiresAt           time.Time  `bun:"expires_at,notnull" json:"expires_at"`
    RevokedAt           *time.Time `bun:"revoked_at" json:"revoked_at"`
    RevokedBy           *uuid.UUID `bun:"revoked_by,type:uuid" json:"revoked_by"`
    MaxQueryCounts      *int64     `bun:"max_query_counts" json:"max_query_counts"`
    MaxBytesTransferred *int64     `bun:"max_bytes_transferred" json:"max_bytes_transferred"`
    CreatedAt           time.Time  `bun:"created_at,notnull,default:current_timestamp" json:"created_at"`

    // Computed fields (not stored in DB)
    QueryCount       int64 `bun:"-" json:"query_count"`
    BytesTransferred int64 `bun:"-" json:"bytes_transferred"`
}
```

### AuditLog (UUIDv7)

```go
type AuditLog struct {
    bun.BaseModel `bun:"table:audit_log,alias:al"`

    UID         uuid.UUID       `bun:"uid,pk,type:uuid" json:"uid"`  // UUIDv7 set in Go
    EventType   string          `bun:"event_type,notnull" json:"event_type"`
    UserID      *uuid.UUID      `bun:"user_id,type:uuid" json:"user_id"`
    PerformedBy *uuid.UUID      `bun:"performed_by,type:uuid" json:"performed_by"`
    Details     json.RawMessage `bun:"details,type:jsonb" json:"details"`
    CreatedAt   time.Time       `bun:"created_at,notnull,default:current_timestamp" json:"created_at"`
}
```

## UUIDv7 Generation

For `connections`, `queries`, `query_result_rows`, and `audit_log`, generate UUIDv7 in Go before insert:

```go
import "github.com/google/uuid"

// Generate UUIDv7 for high-volume tables
func newUIDv7() uuid.UUID {
    uid, err := uuid.NewV7()
    if err != nil {
        // Fallback to V4 if V7 fails (should never happen)
        return uuid.New()
    }
    return uid
}
```

### Usage in Store

```go
func (s *Store) CreateConnection(ctx context.Context, conn *Connection) error {
    conn.UID = newUIDv7()  // Generate UUIDv7 before insert
    _, err := s.db.NewInsert().Model(conn).Exec(ctx)
    return err
}

func (s *Store) CreateQuery(ctx context.Context, query *Query) error {
    query.UID = newUIDv7()  // Generate UUIDv7 before insert
    _, err := s.db.NewInsert().Model(query).Exec(ctx)
    return err
}

func (s *Store) StoreQueryRows(ctx context.Context, queryUID uuid.UUID, rows []QueryRow) error {
    if len(rows) == 0 {
        return nil
    }

    resultRows := make([]QueryResultRow, len(rows))
    for i, row := range rows {
        resultRows[i] = QueryResultRow{
            UID:          newUIDv7(),  // Generate UUIDv7 for each row
            QueryID:      queryUID,
            RowNumber:    row.RowNumber,
            RowData:      row.RowData,
            RowSizeBytes: row.RowSizeBytes,
        }
    }

    _, err := s.db.NewInsert().Model(&resultRows).Exec(ctx)
    return err
}

func (s *Store) LogAuditEvent(ctx context.Context, event *AuditLog) error {
    event.UID = newUIDv7()  // Generate UUIDv7 before insert
    _, err := s.db.NewInsert().Model(event).Exec(ctx)
    return err
}
```

## Store Changes

Update all function signatures to use `uuid.UUID`:

```go
// Users
func (s *Store) GetUserByUID(ctx context.Context, uid uuid.UUID) (*User, error)
func (s *Store) UpdateUser(ctx context.Context, uid uuid.UUID, updates UserUpdate) error
func (s *Store) DeleteUser(ctx context.Context, uid uuid.UUID) error

// Databases
func (s *Store) GetDatabaseByUID(ctx context.Context, uid uuid.UUID) (*Database, error)
func (s *Store) UpdateDatabase(ctx context.Context, uid uuid.UUID, updates DatabaseUpdate) error
func (s *Store) DeleteDatabase(ctx context.Context, uid uuid.UUID) error

// Grants
func (s *Store) GetGrantByUID(ctx context.Context, uid uuid.UUID) (*AccessGrant, error)
func (s *Store) GetActiveGrant(ctx context.Context, userID, databaseID uuid.UUID) (*AccessGrant, error)
func (s *Store) RevokeGrant(ctx context.Context, uid uuid.UUID, revokedBy uuid.UUID) error

// Connections
func (s *Store) CloseConnection(ctx context.Context, uid uuid.UUID) error

// Queries
func (s *Store) GetQueryByUID(ctx context.Context, uid uuid.UUID) (*Query, error)
func (s *Store) StoreQueryRows(ctx context.Context, queryID uuid.UUID, rows []QueryRow) error
```

### Filter Structs

```go
type ConnectionFilter struct {
    UserID     *uuid.UUID
    DatabaseID *uuid.UUID
    Limit      int
    Offset     int
}

type QueryFilter struct {
    ConnectionID *uuid.UUID
    UserID       *uuid.UUID
    DatabaseID   *uuid.UUID
    StartTime    *time.Time
    EndTime      *time.Time
    Limit        int
    Offset       int
}

type GrantFilter struct {
    UserID     *uuid.UUID
    DatabaseID *uuid.UUID
    ActiveOnly bool
}

type AuditFilter struct {
    EventType   *string
    UserID      *uuid.UUID
    PerformedBy *uuid.UUID
    StartTime   *time.Time
    EndTime     *time.Time
    Limit       int
    Offset      int
}
```

## API Changes

### URL Parameter

Change route parameter from `:id` to `:uid`:

```go
users.GET("/:uid", s.handleGetUser)
users.PUT("/:uid", s.handleUpdateUser)
users.DELETE("/:uid", s.requireAdmin(), s.handleDeleteUser)
// ... same for all routes
```

### Helper Function

```go
import "github.com/google/uuid"

func parseUIDParam(c *gin.Context) (uuid.UUID, error) {
    uid := c.Param("uid")
    parsed, err := uuid.Parse(uid)
    if err != nil {
        return uuid.Nil, ErrInvalidUID
    }
    return parsed, nil
}
```

### Request Structs

```go
type CreateGrantRequest struct {
    UserID              uuid.UUID `json:"user_id" binding:"required"`
    DatabaseID          uuid.UUID `json:"database_id" binding:"required"`
    AccessLevel         string    `json:"access_level" binding:"required,oneof=read write"`
    StartsAt            time.Time `json:"starts_at" binding:"required"`
    ExpiresAt           time.Time `json:"expires_at" binding:"required"`
    MaxQueryCounts      *int64    `json:"max_query_counts"`
    MaxBytesTransferred *int64    `json:"max_bytes_transferred"`
}
```

### Handler Example

```go
func (s *Server) handleGetUser(c *gin.Context) {
    uid, err := parseUIDParam(c)
    if err != nil {
        errorResponse(c, http.StatusBadRequest, "invalid user UID")
        return
    }

    user, err := s.store.GetUserByUID(c.Request.Context(), uid)
    if err != nil {
        errorResponse(c, http.StatusNotFound, "user not found")
        return
    }

    successResponse(c, user)
}
```

## API Examples

### Before (Integer IDs)

```bash
# Response
{"id": 1, "username": "testuser", ...}

# Create grant
curl -X POST /api/grants -d '{"user_id": 1, "database_id": 1, ...}'

# Get user
curl /api/users/1
```

### After (UUIDs)

```bash
# Response
{"uid": "550e8400-e29b-41d4-a716-446655440000", "username": "testuser", ...}

# Create grant
curl -X POST /api/grants -d '{
  "user_id": "550e8400-e29b-41d4-a716-446655440000",
  "database_id": "6ba7b810-9dad-11d1-80b4-00c04fd430c8",
  ...
}'

# Get user
curl /api/users/550e8400-e29b-41d4-a716-446655440000
```

## Dependencies

Add the Google UUID library (v1.6.0+ required for UUIDv7 support):

```bash
go get github.com/google/uuid@latest
```

## Implementation Order

1. Add `github.com/google/uuid` to go.mod
2. Update initial schema (`20260107000000_initial_schema.up.sql` and `.down.sql`)
3. Update all models (change `ID int64` to `UID uuid.UUID`)
4. Update store function signatures and implementations
5. Update filter structs
6. Add `parseUIDParam` helper, remove `parseIDParam`
7. Update API routes (`:id` to `:uid`)
8. Update API request structs
9. Update all API handlers
10. Update proxy code (session, auth) to use UUIDs
11. Update tests
12. Update OpenAPI spec (docs/openapi.yml)
13. Update CLAUDE.md documentation

## Testing

- Test UUID parsing (valid, invalid, nil)
- Test model JSON serialization (field named `uid`)
- Create resources, verify UUID returned
- Foreign key relationships work correctly
- All existing tests updated to use UUIDs

## Notes

- This is a breaking change - requires fresh database
- Field is named `uid` everywhere (DB column, Go field, JSON)
- Foreign key fields keep descriptive names (`user_id`, `database_id`, etc.)
